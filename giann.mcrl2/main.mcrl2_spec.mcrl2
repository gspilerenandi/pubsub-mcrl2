sort
  % fixed set of locations and topics
  % locations are denoted by Loc
  Loc = struct loc1 | loc2 | loc3 | locbr;
  % topics are denoted by Top
  Top = struct top1 | top2;
  % data values used in the system 
  Ev = struct ev1 | ev2;

  % used by the broker to store pubs and subs  
  loc_top = struct p_loc_top(location: Loc, topic: Top);
  % set containing pairs of locations and topics
  varrho = Set(loc_top);

  top_loc = struct p_top_loc(topic': Top, location': Loc);
  % set containing pairs of topics and locations  
  sigma = Set(top_loc);

  % used by the publisher to store outgoing data
  %BPL = struct bpl(getB:List(Int),getBL:Set(L));
  %T_Buffer = Tau -> BPL;

  % an event-buffer contains a list of sets of pairs of events and locations
  ev_loc = struct p_ev_loc(event: Ev, location'': Loc);
  EvxLoc = Set(ev_loc);
  B = List(EvxLoc);
  TxB = Top -> B;	

% Auxiliary functions
map add_top_loc: sigma # Top # Loc -> sigma;
 	in_Top_Loc: sigma # Top # Loc -> Bool;
 	sig_containsTop: sigma # Top -> Bool;
 	emptyB: TxB;
    addtoB: TxB # Top # B -> TxB;
	%eqn    addtoB(tb,t,l) = tb[t -> p_ev_loc( event(tb(t)) , location''(tb(t))+{l} )];
	add_loc_top: varrho # Loc # Top -> varrho;
	in_loc_top: varrho # Loc # Top -> Bool;
	vr_containsTop: varrho # Top -> Bool;

var t:Top;
	l:Loc;
	sigma':sigma;
	varrho':varrho;
	ev_loc': ev_loc;
	B': B;
	B'': B;
    TxB':TxB;

eqn add_top_loc(sigma',t,l) = sigma' + {p_top_loc(t,l)};
    in_Top_Loc(sigma',t,l) = p_top_loc(t,l) in sigma';
 	sig_containsTop(sigma',t) = exists l:Loc . p_top_loc(t,l) in sigma';
	emptyB = lambda t:Top.([]);
    addtoB(TxB',t,B'') = TxB'[t -> B' ++ B''];
	add_loc_top(varrho',l,t) = varrho' + {p_loc_top(l,t)};
 	in_loc_top(varrho',l,t) = p_loc_top(l,t) in varrho';
	vr_containsTop(varrho',t) = exists l:Loc . p_loc_top(l,t) in varrho';

act
  a, b, c;
    sub,  subP,  subS,  subB: Loc # Top;
  unsub,unsubP,unsubS,unsubB: Loc # Top;

%%%%%%%%%%

proc

Pub = a.b.Pub;

% Subscriber state:
%  l - location
%  psi_l - subscribed topics
Sub(l:Loc,psi_l:Set(Top)) =
 sum t':Top .
   subS(l,t') . Sub(l,psi_l + {t'});

% Publisher state:
%   l - location
%   tb - buffer of topics (topic -> B x Set(Loc)) 
Pub(l:Loc,txb:TxB,b:B) =
 sum l':Loc, t':Top .
   subP(l' ,t') .
   Pub(l,addtoB(txb,t',b),b);

% Broker state:
%   l - location
%   pubs: publishers  (locs) and their topics
%   subs: subscribers (locs) and their topics
Brk(l:Loc, pubs:varrho, subs: sigma) = 
  sum l':Loc,t':Top .
    subB(l',t') .
    Brk(l,pubs,subs + {p_top_loc(t',l')});

% Currently only synchronising with one of the publishers
Prog = 
  allow( {sub},
  comm( {subS|subP|subB -> sub}
      , Sub(loc1,{}) ||
		Sub(loc2,{}) ||
        Pub(loc2,emptyB, []) ||
        Pub(loc3,emptyB, []) ||	
        Brk(locbr,{},{})
  ));


%%%%%%%

init

  %Sub(l1,{});
  %Brk(l1,{},{});
  %Pub(l1,emptyTopBuffer);
  Prog;