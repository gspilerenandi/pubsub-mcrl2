sort
  % fixed set of locations and topics
  % locations are denoted by Loc
  %Loc = struct loc1 | loc2 ;
  Loc = struct loc1 | loc2 | loc3 | loc4 | locbrk;

  % topics are denoted by Top
  Top = struct top1 | top2;
  % data values used in the system
  Ev = struct ev1 | ev2;

  % mapping from a topic to a set of locations
  M_tL = Top -> Set(Loc); % ~~ Top x Loc

  % (topic,event,location)
  t_tel = struct c_tel(get_t: Top, gte_e: Ev, get_l: Loc);
  % E x L
  s_TEL = Set(t_tel);
  B = List(s_TEL);
  % maps a location to an event-buffer
  l_m_B = Loc -> B;

% Auxiliary functions
map
  sub_l: M_tL # Top # Loc -> M_tL;
  unsub_l: M_tL # Top # Loc -> M_tL;
  empty_LocSet: Set(Loc);
  empty_tLoc: M_tL;
  add_pub_t: M_tL # Top # Loc -> M_tL;
  remov_pub_t: M_tL # Top # Loc -> M_tL;

  in_tL: Top # Loc -> Bool;

var
  t:Top;
	l, lb, ls:Loc;
	t_tel': t_tel;
	B': B;
  tes: s_TEL;
  chi: M_tL;

eqn
  sub_l(chi, t, ls) = chi[t -> chi(t) + {ls}];
  unsub_l(chi, t, ls) = chi[t -> chi(t) - {ls}];
  %sig_add_l(sigma', lb, t, ls) = sigma'[ lb -> sigma'(lb)[t -> (sigma'(lb))(t) + {ls}]];
  add_pub_t(chi, t, ls) = chi[t -> chi(t) + {ls}];
  remov_pub_t(chi, t, ls) = chi[t -> chi(t) - {ls}];

  empty_LocSet = {};
  empty_tLoc = lambda t:Top.empty_LocSet;

  %in_tL(chi, t, ls) = exists chi[t -> chi(ls)] in chi;

  %append_to_B(B', tes) = B' <| tes;
  %teste(t,p_TxL') =  {y: p_tSubs | y in p_TxL' && get_t'(y) == t};

act
  a, b, c;
  sub,  subP,  subS,  subB: Loc # Top;
  unsub,unsubP,unsubS,unsubB: Loc # Top;
  addpubt,removpubt: Loc # Top;

proc

% Subscriber state:
%  l - location
%  psi_l - subscribed topics
Sub(ls:Loc, psi_l:Set(Top)) =
  sum t':Top .
    subS(ls, t') . Sub(ls, psi_l + {t'})
  +
  sum t':Top .
    unsubS(ls, t') . Sub(ls, psi_l - {t'})
;

% Publisher state:
% lp - publisher's location
% p_tl - pair that represents topics and subscribers (topic, L)
% b - list contaning sets of triples of (topic, event, subscriber)
Pub(lp:Loc, chi: M_tL, b:B) =
  sum l':Loc, t': Top .
    subP(l', t') .
      Pub(lp, sub_l(chi, t', l'), b)
  +
  sum l':Loc, t': Top .
    unsubP(l', t') .
      Pub(lp, unsub_l(chi, t', l'), b)
;

% Broker state:
%   l - location
%   pubs: publishers  (locs) and their topics
%   subs: subscribers (locs) and their topics
%   still missing the sync buffer
Brk(lb:Loc, rho: M_tL, sigma: M_tL) =
  sum l':Loc,t':Top .
    subB(l',t') .
    Brk(lb, rho, sub_l(sigma, t', l'))
  +
  sum l':Loc,t':Top .
    unsubB(l',t') .
    Brk(lb, rho, unsub_l(sigma, t', l'))
  +
  sum l':Loc,t':Top .
    addpubt(l',t') .
    Brk(lb, add_pub_t(rho, t', l'), sigma)
  +
  sum l':Loc,t':Top .
    removpubt(l',t') .
    Brk(lb, remov_pub_t(rho, t', l'), sigma)
;

Prog =
  allow( {sub, unsub, addpubt, removpubt},
  	comm( {subS|subB|subP -> sub, unsubS|unsubB|unsubP -> unsub},
      Sub(loc1, {}) ||
      Sub(loc4, {}) ||
      Pub(loc2, empty_tLoc, []) ||
      Pub(loc3, empty_tLoc, []) ||
      Brk(locbrk, empty_tLoc, empty_tLoc)
  	)
  )
;

%%%%%%%
init
  Prog;
