sort
  % fixed set of locations and topics
  % locations are denoted by Loc
  Loc = struct loc1 | loc2 ;
  MbLoc = struct L(get_loc:Loc) | nil;
  %Loc = struct loc1 | loc2 | loc3 | locbr;
  % topics are denoted by Top
  Top = struct top1 | top2;
  % data values used in the system
  Ev = struct ev1 | ev2;

  % used by the broker to store pubs and subs
  p_lt = struct c_lt(get_l: Loc, get_t: Top);
  % set containing pairs of locations and topics
  varrho = Set(p_lt);

  p_tl = struct c_tl(get_t: Top, get_l: Loc);
  % set containing pairs of topics and locations
  sigma = Set(p_tl);

  % an event-buffer contains a list of sets of pairs of events and locations
  % (topic,event,location)
  t_tel = struct c_tel(get_t: Top, gte_e: Ev, get_l: Loc);
  % E x L
  s_TEL = Set(t_tel);
  B = List(s_TEL);

  p_tSubs = struct c_tSubs(get_t': Top, get_Subs: Set(Loc));
  s_TSUBS = Set(p_tSubs);

% Auxiliary functions
map
  % used in the broker to add the relationship of a topic and a subscriber
  sig_add_p: sigma # Top # Loc -> sigma;
  % verifies if a pair of sub and a topic is stored in the broker
 	in_sig: sigma # Top # Loc -> Bool;
  % verifies if a topic is being subscribed by any subscriber
 	sig_has_t: sigma # Top -> Bool;
  % appends a set of triples contaning a topic, an event and a subscriber that such event has to be sent to
  append_to_B: B # s_TEL -> B;
  % used in the broker to add the relationship of a publisher and a topic
	vr_add_p: varrho # Loc # Top -> varrho;
  %verifies if the pair of a publisher and a topic is stored in the broker
	in_vr: varrho # Loc # Top -> Bool;
  % verifies if a topic is published on by any publisher
	vr_has_t: varrho # Top -> Bool;
  % updates the set of subscribers and topics
  sub_tSubs: p_tSubs # Loc -> p_tSubs;
  unsub_tSubs: p_tSubs # Loc -> p_tSubs;
  % verifies if a tSubs is a pair in a publisher
  in_TSUBS: s_TSUBS # p_tSubs -> Bool;
  % adds a new topic to a publisher with an empty subscribers set
  % not being used at the moment, as such info is being fixed at startup of the system
  add_tSubs: s_TSUBS # Top -> s_TSUBS;
  teste: Top # s_TSUBS -> s_TSUBS;

var
  t:Top;
	l:Loc;
	sigma':sigma;
	varrho':varrho;
	t_tel': t_tel;
	B': B;
  tes: s_TEL;
  p_tSubs': p_tSubs;
  s_TSUBS': s_TSUBS;
  p_TxL': s_TSUBS;

eqn
  % broker
  % sigma
  sig_add_p(sigma',t,l) = sigma' + {c_tl(t,l)};
  in_sig(sigma',t,l) = c_tl(t,l) in sigma';
	sig_has_t(sigma',t) = exists l:Loc . c_tl(t,l) in sigma';
  % varrho
  vr_add_p(varrho',l,t) = varrho' + {c_lt(l,t)};
  in_vr(varrho',l,t) = c_lt(l,t) in varrho';
  vr_has_t(varrho',t) = exists l:Loc . c_lt(l,t) in varrho';

  % publisher
  append_to_B(B', tes) = B' <| tes;
  sub_tSubs(p_tSubs', l) = c_tSubs(get_t'(p_tSubs'), get_Subs(p_tSubs') + {l});
  unsub_tSubs(p_tSubs', l) = c_tSubs(get_t'(p_tSubs'), get_Subs(p_tSubs') - {l});
  in_TSUBS(s_TSUBS', p_tSubs') = p_tSubs' in s_TSUBS';
  add_tSubs(s_TSUBS', t) = s_TSUBS' + {c_tSubs(t, {})};

  %teste(t,p_TxL') =  {y: p_tSubs | get_t'(p_TxL') == t};
  teste(t,p_TxL') =  {y: p_tSubs | y in p_TxL' && get_t'(y) == t};
  find() = if()

  %(exists L':Set(Loc).(p_TxL' - {c_tSubs(get_t(t),get_Subs(L'))})) + {sub_tSubs(c_tSubs(get_t(t),get_Subs(L')), l)};

act
  a, b, c;
  sub,  subP,  subS,  subB: Loc # Top;
  unsub,unsubP,unsubS,unsubB: Loc # Top;
  %store, updateB;

proc

%Pub = a.b.Pub;

%Test(p_TxL:s_TSUBS) = a . Test( teste(top1,p_TxL) ) ;

% Subscriber state:
%  l - location
%  psi_l - subscribed topics
Sub(l:Loc, psi_l:Set(Top)) =
  sum t':Top .
    subS(l,t') . Sub(l,psi_l + {t'})
  +
  sum t':Top .
    unsubS(l,t') . Sub(l,psi_l - {t'});

% Publisher state:
% lp - publisher's location
% p_tl - pair that represents topics and subscribers (topic, L)
% b - list contaning sets of triples of (topic, event, subscriber)
Pub(lp:Loc, p_TxL:s_TSUBS, b:B) =
  sum l':Loc, t': Top .
    subP(l', t') .
      Pub(lp, (p_TxL - teste(t', p_TxL)) + c_tSubs(get_t'(teste(t', p_TxL)), get_Subs(teste(t', p_TxL)) + {l'}), b)
        %Pub(lp, p_TxL, b)

  +
  sum l':Loc, t': Top , L':Set(Loc).
    unsubP(l', t') .
      (c_tSubs(t',L') in p_TxL) ->
        Pub(lp, (p_TxL - {c_tSubs(t',L')}) + {unsub_tSubs(c_tSubs(t',L'), l')}, b)
        <>
        Pub(lp, p_TxL, b);

% Broker state:
%   l - location
%   pubs: publishers  (locs) and their topics
%   subs: subscribers (locs) and their topics
%   still missing the sync buffer
Brk(l:Loc, pubs:varrho, subs: sigma) =
  sum l':Loc,t':Top .
    subB(l',t') .
    Brk(l,pubs,subs + {c_tl(t',l')})
  +
  sum l':Loc,t':Top .
    unsubB(l',t') .
    Brk(l,pubs,subs - {c_tl(t',l')})
;

Prog =
  allow( {sub, unsub},
  	comm( {subS|subB|subP -> sub, unsubS|unsubB|unsubP -> unsub},
      Sub(loc1,{}) ||
		  %Sub(loc2,{}) ||
      Pub(loc2,{c_tSubs(top1,{}), c_tSubs(top2,{})}, []) ||
      %Pub(loc3,{c_tSubs(top2,{})}, []) ||
      Brk(loc1,{c_lt(loc2,top1),c_lt(loc2,top2)},{})
      %Brk(locbr,{c_lt(loc2,top1),c_lt(loc2,top2),c_lt(loc3, top2)},{})
  	)
  );

%%%%%%%

init
  %Sub(l1,{});
  %Brk(l1,{},{});
  %Pub(l1,emptyTopBuffer);
  Prog;
  %Test({ c_tSubs(top2,{}) , c_tSubs(top1,{loc1}) });
