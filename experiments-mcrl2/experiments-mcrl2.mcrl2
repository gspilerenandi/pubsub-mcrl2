sort
  % fixed set of locations and topics
  Loc = struct p1 | p2 | s1 | s2;
  Top = struct t1 | t2;

  Data = struct d1 | d2;

  % Outgoing Buffers
  BrkBuffer = List(Set(EntryBB));
  EntryBB = struct entryBB(to:Loc, from:Loc, top:Top, isSub:Bool);

  PubBuffer = List(EntryPB);
  EntryPB = struct entryPB(value:Data, top:Top, to:Loc);

  % known subscribers by a publisher
  ToNotify = Top -> Set(Loc);

  % known topics by a publisher (fixed constant)
  ToPublish = Loc -> Set(Top);

  % known subscribers by the broker
  Subscribers = Top -> Set(Loc);


% Constant relation from publishers to topics
map allPubs:ToPublish;
eqn allPubs = (lambda l.{})[p1->{t1}, p2->{t1,t2}]


% Auxiliary functions
var top:Top;
    loc:Loc;
    subs:Subscribers;
    isSub:Bool;
    toPubs:ToPublish;
    toNotfs:ToNotify;
    bbuffer:BrkBuffer;

    tl:TopLocs;
    tb:TopBuffer;


map addSub, rmSub: Loc # Top # Subscribers -> Subscribers;
eqn addSub(loc,top,subs) = subs[top -> subs(top)+{loc}];
     rmSub(loc,top,subs) = subs[top -> subs(top)-{loc}];

map addPub, rmPub: Top # Loc # ToPublish -> ToPublish;
eqn addPub(top,loc,toPubs) = toPubs[loc -> toPubs(loc)+{top}];
     rmPub(top,loc,toPubs) = toPubs[loc -> toPubs(loc)-{top}];

map addNotf, rmNotf: Loc # Top # ToNotify -> toNotify;
eqn addNotf(loc,key,toNotfs) = toNotfs[key -> toNotfs(key)+{loc}];
     rmNotf(loc,key,toNotfs) = toNotfs[key -> toNotfs(key)-{loc}];

map addBBuffer: Loc # Top # Bool # BrkBuffer -> BrkBuffer
eqn addBBuffer(loc,top,isSub,bbuffer) =
  % { entry(to,from,top,isSub) | l:Loc, top in allPubs(l)} |> bbuffer
  {e:EntryBB | forall l:Loc, l in loc }


  % used by the broker to store pubs and subs
  % TopLoc = struct topLoc(top: Top, loc: Loc);
  % TopLocs = Set(TopLoc);

  % Used by the publisher to store outgoing data
  % BPL = struct bpl(getB:List(Int),getBLocs:Set(Loc));
  % TopBuffer = Top -> BPL;
  

% Auxiliary functions
% var t:Top;
% 	l:Loc;
% 	tl:TopLocs;
%     tb:TopBuffer;

% map addTL: TopLocs # Top # Loc -> TopLocs;
% eqn addTL(tl,t,l) = tl + {topLoc(t,l)};

% map hasTL: TopLocs # Top # Loc -> Bool;
% eqn hasTL(tl,t,l) = topLoc(t,l) in tl;

% map hasTop: TopLocs # Top -> Bool;
% eqn hasTop(tl,t) = exists l:Loc . topLoc(t,l) in tl;

% map emptyBuf: TopBuffer;
% eqn emptyBuf = lambda t:Top . bpl([],{});

% map addBuf: TopBuffer # Top # Loc -> TopBuffer;
% eqn addBuf(tb,t,l) = tb[t -> bpl( getB(tb(t)) , getBLocs(tb(t))+{l} )];


    %%


act
  a, b, c;
    sub,  subS,  subB: Loc # Top;
  unsub,unsubS,unsubB: Loc # Top;
   push, pushP, pushB: Loc # Bool # Loc # Top;
    pub: Data # Top;
  notify, notifyP, notifyS: Data # Top # Loc;


%%%%%%%%%%

proc


% Subscriber state:
%  l - location
%  ts - subscribed topics
Sub(l:Loc,ts:Set(Top)) =
 sum t':Top .
   subS(l,t') . Sub(l,ts + {t'});

% Publisher state:
%   l - location
%   tb - buffer of topics (topic -> B x Set(Loc)) 
Pub(l:Loc,tb:TopBuffer) =
 sum l':Loc, t':Top .
   subP(l' ,t') .
   Pub(l,addBuf(tb,t',l'));
    %tb[t' -> bpl( getB(tb(t')) , getBLocs(tb(t'))+{l'} )]);

% Broker state:
%   l - location
%   pubs: publishers  (locs) and their topics
%   subs: subscribers (locs) and their topics
Brk(l:Loc, pubs:TopLocs, subs: TopLocs) = 
  sum l':Loc,t':Top .
    subB(l',t') .
    Brk(l,pubs,subs + {topLoc(t',l')});

% Currently only synchronising with one of the publishers
Prog = 
  allow( {sub},
  comm( {subS|subP|subB -> sub}
      , Sub(l1,{}) ||
        Pub(l2,emptyBuf) ||
        Pub(l3,emptyBuf) ||
        Brk(lbr,{},{})
  ));


%%%%%%%

init

  %Sub(l1,{});
  %Brk(l1,{},{});
  %Pub(l1,emptyTopBuffer);
  Prog;